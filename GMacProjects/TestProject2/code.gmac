/*
namespace common

template macro versorInverse( mv : Multivector) : Multivector
begin
    let b = reverse( mv )
    let a = mv gp b
    
    return b / a.#E0#
end

namespace geometry2d

frame cgaOrtho (ep, e1, e2, en) orthonormal '+++-'

frame cga (no, e1, e2, ni) 
    CBM cgaOrtho @"
    {
        {1/2,  0,  0, 1/2},
        {  0,  1,  0,   0},
        {  0,  0,  1,   0},
        { -1,  0,  0,   1}
    }"

open common

implement versorInverse using cgaOrtho, cga

macro cga.rotate(mv : Multivector, angle : scalar) : Multivector
begin
    let V = 'Cos[$ angle/2 $]' - 'Sin[$ angle/2 $]' * (e1^e2)

    return V gp mv gp versorInverse(V)
end

namespace geometry3d

frame cgaOrtho (ep, e1, e2, e3, en) orthonormal '++++-'

frame cga (no, e1, e2, e3, ni) 
    CBM cgaOrtho @"
    {
        {1/2,  0,  0,  0, 1/2},
        {  0,  1,  0,  0,   0},
        {  0,  0,  1,  0,   0},
        {  0,  0,  0,  1,   0},
        { -1,  0,  0,  0,   1}
    }"

*/

namespace common

constant Pi = 'Pi'

constant E = 'E'

macro sin(d : scalar) : scalar
begin
    return 'Sin[$d$]'
end

macro cos(d : scalar) : scalar
begin
    return 'Cos[$d$]'
end

macro sqrt(d : scalar) : scalar
begin
    return 'Sqrt[$d$]'
end

template macro versorInverse( mv : Multivector) : Multivector
begin
    let b = reverse( mv )
    let a = mv gp b
    
    return b / a.#E0#
end

template macro normalize ( mv : Multivector ) : Multivector  
begin 
    return mv / 'Sqrt[$ norm2( mv ) $]'
end 

//The 2D Geometry Namespace
namespace geometry2d

frame cgaOrtho0 (ep, en) orthonormal '+-'
frame cga0 (no, ni) 
    CBM cgaOrtho0 @"
    {
        {1/2,  1/2},
        { -1,    1}
    }"

frame e2d (e1, e2) euclidean

frame cgaOrtho (ep, e1, e2, en) orthonormal '+++-'

    subspace vectors2D = @e1, e2@

    subspace euclidean2D = @ga{e1, e2}@

    subspace bivectors2D = @e1^e2@

frame cga (no, e1, e2, ni) 
    CBM cgaOrtho @"
    {
        {1/2,  0,  0, 1/2},
        {  0,  1,  0,   0},
        {  0,  0,  1,   0},
        { -1,  0,  0,   1}
    }"

    subspace vectors2D = @e1, e2@
    
    subspace bivectors2D = @e1^e2@

    subspace euclidean2D = @ga{e1, e2}@


open common

implement versorInverse, normalize using e2d, cgaOrtho, cga

macro cga.rotate(mv : Multivector, angle : scalar) : Multivector
begin
    let V = 'Cos[$ angle/2 $]' - 'Sin[$ angle/2 $]' * (e1^e2)

    return V gp mv gp versorInverse(V)
end
    
    
namespace geometry3d

frame e3d (e1, e2, e3) euclidean

frame cgaOrtho (ep, e1, e2, e3, en) orthonormal '++++-'

    subspace vectors3d = @e1, e2, e3@

    subspace bivectors3d = @e1^e2, e1^e3, e2^e3@

    subspace euclidean3d = @ga{e1, e2, e3}@

    frame cga (no, e1, e2, e3, ni) 
    CBM cgaOrtho @"
    {
        {1/2,  0,  0,  0, 1/2},
        {  0,  1,  0,  0,   0},
        {  0,  0,  1,  0,   0},
        {  0,  0,  0,  1,   0},
        { -1,  0,  0,  0,   1}
    }"

    //frame cga (no, e1, e2, e3, ni) 
    //IPM @"
    //{
        //{  0,  0,  0,  0,  -1},
        //{  0,  1,  0,  0,   0},
        //{  0,  0,  1,  0,   0},
        //{  0,  0,  0,  1,   0},
        //{ -1,  0,  0,  0,   0}
    //}"

    subspace vectors3d = @e1, e2, e3@
    
    subspace bivectors3d = @e1^e2, e1^e3, e2^e3@

    subspace euclidean3d = @ga{e1, e2, e3}@


constant cga.I3 = Multivector(#e1^e2^e3# = '1')

constant cga.I3i = Multivector(#e1^e2^e3# = '-1')


open common

implement versorInverse, normalize using e3d, cgaOrtho, cga


structure e3d.ray 
(
    origin : Multivector, 
    direction : Multivector
)

structure e3d.HitInfo 
( 
    Ray : ray, 
    tParameter : scalar,
    HitPoint : Multivector, 
    NormalVector : Multivector 
)


macro cga.ToCgaPoint (point : Multivector) : Multivector 
begin
    let point = point.@vectors3d@
    
    return no + point + (point sp point) / 2 gp ni
end

macro cga.To3DPoint ( p : Multivector ) : Multivector
begin
    return Multivector( #e1# = p.#e1#, #e2# = p.#e2#, #e3# = p.#e3# )
end

macro cga.TranslationVersor (translationVector : Multivector) : Multivector
begin
    return 1 - translationVector.@vectors3d@ gp ni / 2
end

macro cga.RotationVersorUnit (angle : scalar, unitBivector : Multivector) : Multivector
begin
    return cos(angle / 2) - sin(angle / 2) gp unitBivector
end

macro cga.RotationVersor (angle : scalar, bivector : Multivector) : Multivector
begin
    return sin(angle / 2) - cos(angle / 2) gp normalize(bivector)
end

macro cga.ApplyUnitRtor (versor : Multivector, mv : Multivector) : Multivector
begin
    return versor gp mv gp reverse(versor)
end
    
macro cga.ApplyGenlVersor ( versor : Multivector, mv : Multivector) : Multivector
begin
    return versor gp mv gp versorInverse(versor)
end

macro cga.NormalToBivector3D(normal : Multivector) : Multivector
begin
    return normal lcp reverse(I3)
end
    
macro cga.BivectorToNormal3D(bivector : Multivector ) : Multivector
begin
    return bivector lcp I3
end
    

