using System.Collections.Generic;
using System.Linq;
using CodeComposerLib.Irony.Semantic.Command;
using CodeComposerLib.Irony.Semantic.Expression.ValueAccess;
using CodeComposerLib.Irony.Semantic.Scope;
using CodeComposerLib.Irony.Semantic.Symbol;
using CodeComposerLib.Irony.Semantic.Type;
using CodeComposerLib.Irony.SourceCode;
using GMac.Engine.Compiler.Semantic.AST.Extensions;
using GMac.Engine.Compiler.Syntax;
using Irony.Parsing;

namespace GMac.Engine.Compiler.Semantic.ASTGenerator
{
    internal sealed class GMacCommandGenerator : GMacAstSymbolGenerator
    {
        public static List<LanguageCommand> Translate(GMacSymbolTranslatorContext context, ParseTreeNode node)
        {
            context.PushState(node);

            var translator = new GMacCommandGenerator();//new GMacCommandGenerator(context);

            translator.SetContext(context);
            translator.Translate();

            context.PopState();

            var result = translator._generatedCommands;

            //MasterPool.Release(translator);

            return result;
        }

        
        /// <summary>
        /// There may be more than one commend generated by this translator. For example a let command
        /// may generate an implicit declare before it
        /// </summary>
        private readonly List<LanguageCommand> _generatedCommands = new List<LanguageCommand>();


        //public override void ResetOnAcquire()
        //{
        //    base.ResetOnAcquire();

        //    _generatedCommand = null;
        //}


        private CommandDeclareVariable translate_Declare(string identifierName, ILanguageType identifierType)
        {
            return
                Context.ActiveParentCommandBlock.DefineLocalVariable(identifierName, identifierType);
        }

        private CommandDeclareVariable translate_Identifier_Declaration(ParseTreeNode node)
        {
            //Read the name of the member
            var identifierName = GenUtils.Translate_Identifier(node.ChildNodes[0]);

            if (Context.ActiveParentScope.SymbolExists(identifierName))
                return CompilationLog.RaiseGeneratorError<CommandDeclareVariable>("Identifier name already used", node.ChildNodes[0]);

            var identifierType = GMacValueAccessGenerator.Translate_Direct_LanguageType(Context, node.ChildNodes[1]);

            return translate_Declare(identifierName, identifierType);
        }

        private void translate_Command_Declare(ParseTreeNode node)
        {
            translate_Identifier_Declaration(node.ChildNodes[0]);
        }

        private static bool TryTranslate_LValue(GMacSymbolTranslatorContext context, ParseTreeNode node, out LanguageValueAccess varAccess)
        {
            var qualList = GenUtils.Translate_Qualified_Identifier(node);

            var flag =
                context
                .OpenedDistinctScopes()
                .LookupSymbol(qualList.FirstItem, out var symbol);

            if (flag == false || (symbol is SymbolLValue) == false)
            {
                varAccess = null;
                return false;
            }

            varAccess = LanguageValueAccess.Create(symbol);

            return true;
        }

        private LanguageValueAccess translate_Command_Let_LHS_Qualified_Item(ILanguageType rhsType, ParseTreeNode node)
        {
            node.Assert(GMacParseNodeNames.QualifiedItem);

            var subNode = node.ChildNodes[0];

            switch (subNode.ToString())
            {
                case GMacParseNodeNames.QualifiedBasisBladesSet:
                case GMacParseNodeNames.QualifiedBasisBladeCoefficient:
                    return GMacValueAccessGenerator.Translate(Context, subNode, true);

                case GMacParseNodeNames.QualifiedIdentifier:
                    if (subNode.ChildNodes.Count == 1)
                    {
                        var flag = TryTranslate_LValue(Context, subNode, out var varAccess);

                        if (flag)
                            return varAccess;

                        var identifierName = subNode.ChildNodes[0].FindTokenAndGetText();

                        if (Context.ActiveParentScope.SymbolExists(identifierName))
                            CompilationLog.RaiseGeneratorError<LanguageValueAccess>("Identifier name already used", node.ChildNodes[0]);

                        var declareCommand = translate_Declare(identifierName, rhsType);

                        return LanguageValueAccess.Create(declareCommand.DataStore);
                    }
                    
                    return GMacValueAccessGenerator.Translate(Context, subNode, true);

                default:
                    return CompilationLog.RaiseGeneratorError<LanguageValueAccess>("Unknown LHS node!!", node);
            }
        }

        private LanguageValueAccess translate_Command_Let_LHS(ILanguageType rhsType, ParseTreeNode node)
        {
            var subNode = node.ChildNodes[0];

            switch (subNode.ToString())
            {
                case GMacParseNodeNames.IdentifierDeclaration:
                    var declareCommand = translate_Identifier_Declaration(subNode);

                    return LanguageValueAccess.Create(declareCommand.DataStore);

                case GMacParseNodeNames.QualifiedItem:
                    return translate_Command_Let_LHS_Qualified_Item(rhsType, subNode);

                default:
                    return CompilationLog.RaiseGeneratorError<LanguageValueAccess>("Unknown LHS node!!", node);
            }
        }

        //Translate a 'let' statement
        private void translate_Command_Let(ParseTreeNode node)
        {
            var rhsExpr = GMacExpressionGenerator.Translate(Context, node.ChildNodes[1]);

            var lhsValue = translate_Command_Let_LHS(rhsExpr.ExpressionType, node.ChildNodes[0]);

            if (lhsValue.IsOutputParameter)
                CompilationLog.RaiseGeneratorError<int>("Assignment to the output parameter not allowed. Use return <expression> instead", node);

            if (lhsValue.ExpressionType.CanAssignValue(rhsExpr.ExpressionType))
                Context.ActiveParentCommandBlock.AddCommand_Assign(lhsValue, rhsExpr);

            else
                CompilationLog.RaiseGeneratorError<int>(
                    "Cannot assign RHS of type " + rhsExpr.ExpressionType.TypeSignature + " to LHS of type " +
                    lhsValue.ExpressionType.TypeSignature, node);
        }

        private void translate_Command_Return(ParseTreeNode node)
        {
            var macro = Context.NearestParentMacro;

            if (macro == null)
                CompilationLog.RaiseGeneratorError<int>("Cannot use a return command outside of a macro definition body", node);

            else
            {
                var lhsValue = LanguageValueAccess.Create(macro.OutputParameter);

                var rhsExpr = GMacExpressionGenerator.Translate(Context, node.ChildNodes[0]);

                if (lhsValue.ExpressionType.CanAssignValue(rhsExpr.ExpressionType))
                    Context.ActiveParentCommandBlock.AddCommand_Assign(lhsValue, rhsExpr);

                else
                    CompilationLog.RaiseGeneratorError<int>(
                        "Cannot assign RHS of type " + rhsExpr.ExpressionType.TypeSignature + " to LHS of type " +
                        lhsValue.ExpressionType.TypeSignature, node);
            }
        }

        protected override void Translate()
        {
            RootParseNode.Assert(GMacParseNodeNames.Command);

            var oldCommandsCount = Context.ActiveParentCommandBlock.CommandsCount;

            var subNode = RootParseNode.ChildNodes[0];

            switch (subNode.ToString())
            {
                case GMacParseNodeNames.CommandDeclare:
                    translate_Command_Declare(subNode);
                    break;

                case GMacParseNodeNames.CommandLet:
                    translate_Command_Let(subNode);
                    break;

                case GMacParseNodeNames.CommandReturn:
                    translate_Command_Return(subNode);
                    break;

                //case GMacParseNodeNames.Command_Output:
                //    this.translate_Command_Output(sub_node);
                //    break;

                case GMacParseNodeNames.CommandBlock:
                    GMacCommandBlockGenerator.Translate(Context, subNode);
                    break;

                default:
                    CompilationLog.RaiseGeneratorError<int>("Command not recognized", RootParseNode);
                    break;
            }

            _generatedCommands.AddRange(Context.ActiveParentCommandBlock.Commands.Skip(oldCommandsCount));
        }
    }
}
